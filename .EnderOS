--Coded by SuicidalSTDz
--License:
--The code of "EnderOS" in any form is intellectual
--property of SuicidalSTDz. You may not reproduce,
--redistribute, or modify it in any way!

--This Graphical Shell stores User information in a hashed form. Making "hackers" tremble in fear >:) Not really...
--The hash that EnderOS uses is Sha-256 and makes storage safer :)

--[[Games]]--
--SkullPong by Skullblade
--FireWolf by GravityScore
--A Calculator by Engineer
--Guess That Color! by me

--If you find any bugs please report them on the EnderOS thread!
--You can also report bugs here: http://suicidalstdz.koding.com/main.php
--Thank you for using EnderOS and enjoy!

--[[Prevent Termination]]--
os.pullEvent = os.pullEventRaw

--[[Variables]]--
local w, h = term.getSize()
local version = "v4.0"
local col = term.setTextColour
local saltHash = "something"

--[[Programs]]--
local firewolf = "A7wGH3ty"
local skullPong = "8LU0sjFR"
local guessThatColor = "cQ1CbfAg"
local calculator = "8c2hztcz"

--[[Tables]]--
local logo = {
	" _____       _         _____ _____ ";
	"|   __|___ _| |___ ___|     |   __|";
	"|   __|   | . | -_|  _|  |  |__   |";
	"|_____|_|_|___|___|_| |_____|_____|";
	"                                                   ";
	"                                                   ";
	" _____     ";
	"| __  |_ _ ";
	"| __ -| | |";
	"|_____|_  |";
	"      |___|";
	"                                                   ";
	" _____     _     _   _     _ _____ _____ ____      ";
	"|   __|_ _|_|___|_|_| |___| |   __|_   _|    \\ ___ ";
	"|__   | | | |  _| | . | .'| |__   | | | |  |  |- _|";
	"|_____|___|_|___|_|___|__,|_|_____| |_| |____/|___|";
}
local main = {
	["desktop"] = {
		{text = "Log Off", x1 = 3, x2 = 11, y = 19, col = colours.white, bgColour = colours.purple, bracketCol = colours.black, option = "logOff"},
		{text = "Lock", x1 = 14, x2 = 19, y = 19, col = colours.white, bgColour = colours.purple, bracketCol = colours.black, option = "lock"},
		{text = "Exit", x1 = 22, x2 = 27, y = 19, col = colours.white, bgColour = colours.purple, bracketCol = colours.black, option = "exit"},
		{text = "Reboot", x1 = 30, x2 = 37, y = 19, col = colours.white, bgColour = colours.purple, bracketCol = colours.black, option = "reboot"},
		{text = "Shutdown", x1 = 40, x2 = 49, y = 19, col = colours.white, bgColour = colours.purple, bracketCol = colours.black, option = "shutdown"},
		{text = "File Manager", x1 = 2, x2 = 15, y = 3, col = colours.lime, bgColour = colours.black, bracketCol = colours.lightGrey, option = "fileManager"},
		{text = "Programs", x1 = 18, x2 = 27, y = 3, col = colours.lime, bgColour = colours.black, bracketCol = colours.lightGrey, option = "programs"},
		{text = "Games", x1 = 30, x2 = 36, y = 3, col = colours.lime, bgColour = colours.black, bracketCol = colours.lightGrey, option = "games"},
		{text = "Settings", x1 = 39, x2 = 48, y = 3, col = colours.lime, bgColour = colours.black, bracketCol = colours.lightGrey, option = "settings"}
	},
	["fileManager"] = {
		{text = "Back", x1 = 2, x2 = 7, y = h, col = colours.white, bracketCol = colours.black, bgColour = colours.purple, option = "back"},
		{text = "Edit", x1 = 2, x2 = 7, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "edit"},
		{text = "Rename", x1 = 10, x2 = 17, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "rename"},
		{text = "Copy", x1 = 20, x2 = 25, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "copy"},
		{text = "Move", x1 = 28, x2 = 33, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "move"},
		{text = "Delete", x1 = 36, x2 = 43, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "delete"},
		{text = "Run", x1 = 46, x2 = 50, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "run"}
	},
	["settings"] = {
		{text = "Back", x1 = 2, x2 = 7, y = h, col = colours.white, bracketCol = colours.black, bgColour = colours.purple, option = "back"},
		{text = "Username", x1 = 2, x2 = 11, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "changeUsername"},
		{text = "Password", x1 = 14, x2 = 23, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "changePassword"},
		{text = "Hint", x1 = 26, x2 = 31, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "changeHint"},
		{text = "Uninstall", x1 = 34, x2 = 44, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "uninstall"}
	},
	["programs"] = {
		{text = "Back", x1 = 2, x2 = 7, y = h, col = colours.white, bracketCol = colours.black, bgColour = colours.purple, option = "back"},
		{text = "Firewolf", x1 = 3, x2 = 12, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "firewolf"},
		{text = "Caclulator", x1 = 15, x2 = 26, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "calculator"}
	},
	["games"] = {
		{text = "Back", x1 = 2, x2 = 7, y = h, col = colours.white, bracketCol = colours.black, bgColour = colours.purple, option = "back"},
		{text = "SkullPong", x1 = 2, x2 = 12, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "skullPong"},
		{text = "Guess That Color!", x1 = 15, x2 = 33, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "guessThatColor"}
	}
}
local boot = {
	["files"] = {
		{file = "/.calculator", id = calculator},
		{file = "/.firewolf", id = firewolf},
		{file = "/.guessThatColor", id = guessThatColor},
		{file = "/.skullPong", id = skullPong}
	}
}

--[[Functions]]--
local function reset()
	term.clear()
	term.setCursorPos(1,1)
end
local function center(text, y)
  term.setCursorPos(((w-#text)/2)+1,y)
  write(text)
end
local function day_time()
	term.setCursorPos(1,1)
	term.setBackgroundColour(colours.purple)
	col(colours.white)
	term.write("Day "..math.floor(os.day()))
	local mc_time = textutils.formatTime(os.time(),false)
	term.setCursorPos(w-8,1)
	string.rep("",8)
	term.setCursorPos((w-#mc_time)+1,1)
	term.write(mc_time)
	term.setBackgroundColour(colours.black)
end
local function limitRead(limit, char)
	term.setCursorBlink(true)
	local input = ""
	if char == "" then char = nil end
	repeat
		local event, p1 = os.pullEvent()
		if event == "char" then
			if #input + 1 <= limit then
				input = input..p1
				write(char or p1)
			end
		elseif event == "key" and p1 == keys.backspace and #input >= 1 then
			input = string.sub(input, 1, #input-1)
			xPos, yPos = term.getCursorPos()
			term.setCursorPos(xPos-1, yPos)
			write(" ")
			term.setCursorPos(xPos-1, yPos)
		end
	until event == "key" and p1 == keys.enter
	term.setCursorBlink(false)
	return input
end
local function bracket(tab)
	for _,v in pairs(tab) do
		term.setCursorPos(v.x1,v.y)
		term.setTextColour(v.bracketCol)
		term.setBackgroundColour(v.bgColour)
		term.write("[")
		term.setCursorPos(v.x2,v.y)
		term.write("]")
		term.setCursorPos(v.x1+1,v.y)
		term.setTextColour(v.col)
		term.setBackgroundColour(v.bgColour)
		term.write(v.text)
	end
end
local function brackets(x, y, text, colour, bracketCol)
	term.setCursorPos(x-1,y)
	col(bracketCol or colours.lightGrey)
	term.write("[")
	term.setCursorPos(x+#text,y)
	term.write("]")
	term.setCursorPos(x,y)
	col(colour)
	term.write(text)
	col(colours.white)
end
local function pastebinGet(code, path)
	local sPath = shell.resolve(path)
	local response = http.get("http://pastebin.com/raw.php?i="..textutils.urlEncode(code))
	if response then
		local contents = response.readAll()
		response.close()
		local file = fs.open( sPath, "w" )
		file.write(contents)
		file.close()
		return true
	else
		return false
	end	
end
local function sha256(msg)
	local function band(int1, int2, int3, ...)
		local ret =
		((int1%0x00000002>=0x00000001 and int2%0x00000002>=0x00000001 and 0x00000001) or 0)+
		((int1%0x00000004>=0x00000002 and int2%0x00000004>=0x00000002 and 0x00000002) or 0)+
		((int1%0x00000008>=0x00000004 and int2%0x00000008>=0x00000004 and 0x00000004) or 0)+
		((int1%0x00000010>=0x00000008 and int2%0x00000010>=0x00000008 and 0x00000008) or 0)+
		((int1%0x00000020>=0x00000010 and int2%0x00000020>=0x00000010 and 0x00000010) or 0)+
		((int1%0x00000040>=0x00000020 and int2%0x00000040>=0x00000020 and 0x00000020) or 0)+
		((int1%0x00000080>=0x00000040 and int2%0x00000080>=0x00000040 and 0x00000040) or 0)+
		((int1%0x00000100>=0x00000080 and int2%0x00000100>=0x00000080 and 0x00000080) or 0)+
		((int1%0x00000200>=0x00000100 and int2%0x00000200>=0x00000100 and 0x00000100) or 0)+
		((int1%0x00000400>=0x00000200 and int2%0x00000400>=0x00000200 and 0x00000200) or 0)+
		((int1%0x00000800>=0x00000400 and int2%0x00000800>=0x00000400 and 0x00000400) or 0)+
		((int1%0x00001000>=0x00000800 and int2%0x00001000>=0x00000800 and 0x00000800) or 0)+
		((int1%0x00002000>=0x00001000 and int2%0x00002000>=0x00001000 and 0x00001000) or 0)+
		((int1%0x00004000>=0x00002000 and int2%0x00004000>=0x00002000 and 0x00002000) or 0)+
		((int1%0x00008000>=0x00004000 and int2%0x00008000>=0x00004000 and 0x00004000) or 0)+
		((int1%0x00010000>=0x00008000 and int2%0x00010000>=0x00008000 and 0x00008000) or 0)+
		((int1%0x00020000>=0x00010000 and int2%0x00020000>=0x00010000 and 0x00010000) or 0)+
		((int1%0x00040000>=0x00020000 and int2%0x00040000>=0x00020000 and 0x00020000) or 0)+
		((int1%0x00080000>=0x00040000 and int2%0x00080000>=0x00040000 and 0x00040000) or 0)+
		((int1%0x00100000>=0x00080000 and int2%0x00100000>=0x00080000 and 0x00080000) or 0)+
		((int1%0x00200000>=0x00100000 and int2%0x00200000>=0x00100000 and 0x00100000) or 0)+
		((int1%0x00400000>=0x00200000 and int2%0x00400000>=0x00200000 and 0x00200000) or 0)+
		((int1%0x00800000>=0x00400000 and int2%0x00800000>=0x00400000 and 0x00400000) or 0)+
		((int1%0x01000000>=0x00800000 and int2%0x01000000>=0x00800000 and 0x00800000) or 0)+
		((int1%0x02000000>=0x01000000 and int2%0x02000000>=0x01000000 and 0x01000000) or 0)+
		((int1%0x04000000>=0x02000000 and int2%0x04000000>=0x02000000 and 0x02000000) or 0)+
		((int1%0x08000000>=0x04000000 and int2%0x08000000>=0x04000000 and 0x04000000) or 0)+
		((int1%0x10000000>=0x08000000 and int2%0x10000000>=0x08000000 and 0x08000000) or 0)+
		((int1%0x20000000>=0x10000000 and int2%0x20000000>=0x10000000 and 0x10000000) or 0)+
		((int1%0x40000000>=0x20000000 and int2%0x40000000>=0x20000000 and 0x20000000) or 0)+
		((int1%0x80000000>=0x40000000 and int2%0x80000000>=0x40000000 and 0x40000000) or 0)+
		((int1>=0x80000000 and int2>=0x80000000 and 0x80000000) or 0)

		return (int3 and band(ret, int3, ...)) or ret
	end

	local function bxor(int1, int2, int3, ...)
		local ret =
		((int1%0x00000002>=0x00000001 ~= (int2%0x00000002>=0x00000001) and 0x00000001) or 0)+
		((int1%0x00000004>=0x00000002 ~= (int2%0x00000004>=0x00000002) and 0x00000002) or 0)+
		((int1%0x00000008>=0x00000004 ~= (int2%0x00000008>=0x00000004) and 0x00000004) or 0)+
		((int1%0x00000010>=0x00000008 ~= (int2%0x00000010>=0x00000008) and 0x00000008) or 0)+
		((int1%0x00000020>=0x00000010 ~= (int2%0x00000020>=0x00000010) and 0x00000010) or 0)+
		((int1%0x00000040>=0x00000020 ~= (int2%0x00000040>=0x00000020) and 0x00000020) or 0)+
		((int1%0x00000080>=0x00000040 ~= (int2%0x00000080>=0x00000040) and 0x00000040) or 0)+
		((int1%0x00000100>=0x00000080 ~= (int2%0x00000100>=0x00000080) and 0x00000080) or 0)+
		((int1%0x00000200>=0x00000100 ~= (int2%0x00000200>=0x00000100) and 0x00000100) or 0)+
		((int1%0x00000400>=0x00000200 ~= (int2%0x00000400>=0x00000200) and 0x00000200) or 0)+
		((int1%0x00000800>=0x00000400 ~= (int2%0x00000800>=0x00000400) and 0x00000400) or 0)+
		((int1%0x00001000>=0x00000800 ~= (int2%0x00001000>=0x00000800) and 0x00000800) or 0)+
		((int1%0x00002000>=0x00001000 ~= (int2%0x00002000>=0x00001000) and 0x00001000) or 0)+
		((int1%0x00004000>=0x00002000 ~= (int2%0x00004000>=0x00002000) and 0x00002000) or 0)+
		((int1%0x00008000>=0x00004000 ~= (int2%0x00008000>=0x00004000) and 0x00004000) or 0)+
		((int1%0x00010000>=0x00008000 ~= (int2%0x00010000>=0x00008000) and 0x00008000) or 0)+
		((int1%0x00020000>=0x00010000 ~= (int2%0x00020000>=0x00010000) and 0x00010000) or 0)+
		((int1%0x00040000>=0x00020000 ~= (int2%0x00040000>=0x00020000) and 0x00020000) or 0)+
		((int1%0x00080000>=0x00040000 ~= (int2%0x00080000>=0x00040000) and 0x00040000) or 0)+
		((int1%0x00100000>=0x00080000 ~= (int2%0x00100000>=0x00080000) and 0x00080000) or 0)+
		((int1%0x00200000>=0x00100000 ~= (int2%0x00200000>=0x00100000) and 0x00100000) or 0)+
		((int1%0x00400000>=0x00200000 ~= (int2%0x00400000>=0x00200000) and 0x00200000) or 0)+
		((int1%0x00800000>=0x00400000 ~= (int2%0x00800000>=0x00400000) and 0x00400000) or 0)+
		((int1%0x01000000>=0x00800000 ~= (int2%0x01000000>=0x00800000) and 0x00800000) or 0)+
		((int1%0x02000000>=0x01000000 ~= (int2%0x02000000>=0x01000000) and 0x01000000) or 0)+
		((int1%0x04000000>=0x02000000 ~= (int2%0x04000000>=0x02000000) and 0x02000000) or 0)+
		((int1%0x08000000>=0x04000000 ~= (int2%0x08000000>=0x04000000) and 0x04000000) or 0)+
		((int1%0x10000000>=0x08000000 ~= (int2%0x10000000>=0x08000000) and 0x08000000) or 0)+
		((int1%0x20000000>=0x10000000 ~= (int2%0x20000000>=0x10000000) and 0x10000000) or 0)+
		((int1%0x40000000>=0x20000000 ~= (int2%0x40000000>=0x20000000) and 0x20000000) or 0)+
		((int1%0x80000000>=0x40000000 ~= (int2%0x80000000>=0x40000000) and 0x40000000) or 0)+
		((int1>=0x80000000 ~= (int2>=0x80000000) and 0x80000000) or 0)

		return (int3 and bxor(ret, int3, ...)) or ret
	end

	local function bnot(int)
		return 4294967295 - int
	end

	local function rshift(int, by)
		local shifted = int / (2 ^ by)
		return shifted - shifted % 1
	end

	local function rrotate(int, by)
		local shifted = int / (2 ^ by)
		local fraction = shifted % 1
		return (shifted - fraction) + fraction * (2 ^ 32)
	end

	local k = {
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
		0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
		0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
		0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
		0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
		0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
		0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
		0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
		0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	}

	local function str2hexa(s)
		local h = string.gsub(s, ".", function(c)
			return string.format("%02x", string.byte(c))
		end)
		return h
	end

	local function num2s(l, n)
		local s = ""
		for i = 1, n do
			local rem = l % 256
			s = string.char(rem) .. s
			l = (l - rem) / 256
		end
		return s
	end

	local function s232num(s, i)
		local n = 0
		for i = i, i + 3 do n = n*256 + string.byte(s, i) end
		return n
	end

	local function preproc(msg, len)
		local extra = 64 - ((len + 1 + 8) % 64)
		len = num2s(8 * len, 8)
		msg = msg .. "\128" .. string.rep("\0", extra) .. len
		return msg
	end

	local function initH256(H)
		H[1] = 0x6a09e667
		H[2] = 0xbb67ae85
		H[3] = 0x3c6ef372
		H[4] = 0xa54ff53a
		H[5] = 0x510e527f
		H[6] = 0x9b05688c
		H[7] = 0x1f83d9ab
		H[8] = 0x5be0cd19
		return H
	end

	local function digestblock(msg, i, H)
		local w = {}
		for j = 1, 16 do w[j] = s232num(msg, i + (j - 1) * 4) end
		for j = 17, 64 do
			local v = w[j - 15]
			local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))
			v = w[j - 2]
			local s1 = bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))
			w[j] = w[j - 16] + s0 + w[j - 7] + s1
		end

		local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
		for i = 1, 64 do
			local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
			local maj = bxor(band(a, b), band(a, c), band(b, c))
			local t2 = s0 + maj
			local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
			local ch = bxor (band(e, f), band(bnot(e), g))
			local t1 = h + s1 + ch + k[i] + w[i]
			h, g, f, e, d, c, b, a = g, f, e, d + t1, c, b, a, t1 + t2
		end

		H[1] = band(H[1], a)
		H[2] = band(H[2], b)
		H[3] = band(H[3], c)
		H[4] = band(H[4], d)
		H[5] = band(H[5], e)
		H[6] = band(H[6], f)
		H[7] = band(H[7], g)
		H[8] = band(H[8], h)
	end

	msg = preproc(msg, #msg)
	local H = initH256({})
	for i = 1, #msg, 64 do digestblock(msg, i, H) end
	return str2hexa(num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) ..
		num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4))
end
local function defineSettings()
	local function redraw(header, footer)
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		col(colours.white)
		center(footer,h)
		center(header,1)
		print()
		term.setBackgroundColour(colours.black)
		col(colours.white)
	end
	local function username()
		repeat
			redraw("Please enter your desired Username", "Your Username may be up to 28 characters long")
			username = limitRead(28)
			if #username < 2 then
				col(colours.red)
				write("\nThe Endermen hack you in their sleep!")
				sleep(1.5)
			end
		until #username >= 2 and #username <= 28
		local  userWrite = io.open("/.EnderOS/.userInfo","w")
		userWrite:write(sha256(username..saltHash))
		userWrite:close()
	end
	local function password()
		repeat
			redraw("Please enter your desired Password", "Your Password may be up to 28 characters long")
			password = limitRead(28, "*")
			if #password < 2 then
				col(colours.red)
				write("\nThe Endermen hack you in their sleep!")
				sleep(1.5)
			end
		until #password >=2
		local passWrite = io.open("/.EnderOS/.passInfo","w")
		passWrite:write(sha256(password..saltHash))
		passWrite:close()
	end
	local function hint()
		repeat
			redraw("Please enter your desire Password Hint", "Your Password Hint may be up to 30 characters long")
			hint = limitRead(30)
		until #hint <=30
		local hintWrite = io.open("/.EnderOS/.userHint","w")
		hintWrite:write(hint)
		hintWrite:close()
	end
	if fs.exists("/.EnderOS/.userInfo") then
		local userRead = io.open("/.EnderOS/.userInfo","r")
		local userContents = userRead:read()
		userRead:close()
		if userContents == nil then
			username()
		end
	else
		username()
	end
	if fs.exists("/.EnderOS/.passInfo") then
		local passRead = io.open("/.EnderOS/.passInfo","r")
		local passContents = passRead:read()
		passRead:close()
		if passContents == nil then
			password()
		end
	else
		password()
	end
	if fs.exists("/.EnderOS/.userHint") then
		local hintRead = io.open("/.EnderOS/.userHint","r")
		local hintContents = hintRead:read()
		hintRead:close()
		if hintContents == nil then
			hint()
		end
	else
		hint()
	end
end
local function login()
	local screenUI = {
		{text = "Username:", x = 8, y = 8, textCol = colours.orange},
		{text = "Password:", x = 8, y = 10, textCol = colours.orange},
		{text = "Password Hint:", x = 8, y = 12, textCol = colours.blue},
	}
	local motd = {
		"Hello fellow Minecrafter!",
		"Coded by SuicidalSTDz!",
		"Catch me if you can!",
		"Bug tested by Engineer!",
		"Fight through the night!",
		"The Endermen approve, do you?",
		"Hate FORTH? Get Lua!",
		"Who's Notch?",
		"Shut up, or i'll flush you out",
		"It's not bogus, it's an IBM standard",
		"Beware of programmers that carry screwdrivers",
		"LISP = Lots of Irritating Silly Parentheses",
		"Cannot find REALITY.SYS. Universe halted",
		"Warning! Buffer overflow, close the tumbler!",
		"I survived an NT installation",
		"The name is Baud......James Baud",
		"Does fuzzy logic tickle?",
		"All wiyht. Rho sritched mg kegtops awound?",
		"Press every key to continue",
		"Bell Labs Unix -- Reach out and grep someone.",
		"FUBAR - where Geeks go for a drink",
		"Black holes are where God divided by zero",
		"Hey! It compiles! Ship it!",
		"Zap! And there was the blue screen!",
		"What color do you want that database?",
		"Warning! Kernel crashed, Run for your lives!",
		"How's my programming? Call 1-800-DEV-NULL",
		"Quake and uptime do not like each other",
		"God is real, unless declared integer",
		"You sir, are an unknown USB device driver"
	}
	local img = paintutils.loadImage("/.EnderOS/.loginScreen")
	local function screen(msg)
		paintutils.drawImage(img,1,1)
		col(colours.white)
		center(motd[math.random(1,#motd)],h)
		center(msg,1)
		term.setBackgroundColour(colours.black)
		for _,pos in pairs(screenUI) do
			term.setCursorPos(pos.x,pos.y)
			term.setTextColour(pos.textCol)
			term.write(pos.text)
		end
	end
	local userRead = io.open("/.EnderOS/.userInfo","r")
	local userContents = userRead:read()
	userRead:close()
	local passRead = io.open("/.EnderOS/.passInfo","r")
	local passContents = passRead:read()
	passRead:close()
	local hintRead = io.open("/.EnderOS/.userHint","r")
	local hintContents = hintRead:read()
	hintRead:close()
	local times = 0
	repeat
		if fs.exists("/.EnderOS/.lock") then
			screen("This computer is locked")
		else
			screen("EnderOS Login Screen")
		end
		local start = os.clock()
		term.setCursorPos(23,12)
		col(colours.lightGrey)
		term.write(hintContents)
		term.setCursorPos(18,8)
		col(colours.white)
		local username = sha256(limitRead(28)..saltHash)
		term.setCursorPos(18,10)
		local password = sha256(limitRead(28,"*")..saltHash)
		if username ~= userContents and password ~= passContents then
			if os.clock()-start <=1.5 then
				term.setCursorPos(10,7)
				col(colours.red)
				if times < 5 then 
					times = times+1
					term.write("Would you mind slowing down..")
					sleep(2)
				else
					term.write("We didn't want it to come to this..")
					sleep(3)
					os.shutdown()
				end
			end
		end
	until username == userContents and password == passContents
	if fs.exists("/.EnderOS/.lock") then fs.delete("/.EnderOS/.lock") end
end
local function nonModify(path)
	local readOnly = fs.list("/.EnderOS")
	for i = 1,#readOnly do
		if path == i or path == "/.EnderOS" or path == ".EnderOS" then
			return true
		end
	end
	return false
end
local function run(path)
	if fs.exists(path) then
		shell.run(path)
	else
		col(colours.red)
		center(path.."seems to be missing", h)
	end
end
local function fileSelect(opt)
    local w,h = term.getSize()
    local offset = 0
    local lines = fs.list("")
    local pos = {}
    local dir = {}
    local file = ""
	local function nonModify(file)
		if string.find(file,".EnderOS") ~= nil or string.find(file,"startup") ~= nil or fs.isReadOnly(file) then
			return true
		else
			return false
		end
	end
    local function redraw()
		term.clear()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		term.setBackgroundColour(colours.purple)
		term.setTextColour(colours.white)
		center("Please select a file to "..opt,1)
		brackets(w-4,h,"Back",colours.white,colours.black)
		if #dir >0 then brackets(2,h,"Previous Dir",colours.white,colours.black) end
		term.setCursorPos(1,h)
		term.setBackgroundColour(colours.black)
        for i = 2,h-1 do
            term.setCursorPos(1,i)
			term.write(lines[(i-1)+offset])
        end
    end
    redraw()
    local running = true
    while running do
        pos = {}
        if offset == 0 then
            for i = 1,h-2 do
                if lines[i] ~= nil then
					table.insert(pos,{x2 = #lines[i],y = i+1,file = lines[i]})
                end
            end
        end
        if offset > 0 then
			for i = offset+1, (h+offset)-2 do
				if lines[i] ~= nil then
					table.insert(pos, {x2 = #lines[i], y = (i+1)-offset, file = lines[i]})
				end
			end
		end
		os.startTimer(0.05)
        local event,p1,xpos,ypos = os.pullEvent()
        if event == "mouse_scroll" then
            if p1 == 1 and offset < math.max(#lines-(h-2),0) then
                offset = offset+1
                redraw()
            end
            if p1 == -1 and offset > 0 then
                offset = offset-1
                redraw()
            end
        end
        if event == "mouse_click" then
            if (xpos >= (w-5) and xpos <= w and ypos == h) then
				file = nil
                return file
            elseif (xpos >= 1 and xpos <= 14 and ypos == h) and #dir > 0 then
				dir[#dir] = nil
				lines = fs.list(table.concat(dir)) or fs.list("")
				offset = 0
				redraw()
			else
                for _,tab in pairs(pos) do
                    if (xpos >= 1 and xpos <= tab.x2 and ypos == tab.y) then
                        if fs.isDir(table.concat(dir).."/"..tab.file) then
                            if #fs.list(table.concat(dir).."/"..tab.file) > 0 then
                                table.insert(dir, "/"..tab.file)
								lines = fs.list(table.concat(dir))
                                offset = 0
								redraw()
							else
								local err = "End of path *gasp*"
								term.setCursorPos((w-#err)+1,2)
								col(colours.red)
								term.write(err)
								sleep(1)
								redraw()
							end
                        else
							if nonModify(table.concat(dir).."/"..tab.file) then
								local er = "I don't think so"
								term.setCursorPos((w-#er)+1,2)
								term.setTextColour(colours.red)
								term.write(er)
								sleep(1)
								redraw()
							else
								local file = table.concat(dir).."/"..tab.file
								return file
							end
                        end
                    end
                end
            end
        end
		if event == "timer" then
			day_time()
		end
    end
end
local function fileManager()
	local function redraw(header, bracketText)
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		term.setBackgroundColour(colours.purple)
		col(colours.white)
		center(header,1)
		if bracketText then bracket(bracketText) end
		term.setBackgroundColour(colours.black)
	end
	local function edit(fileSelectHeader)
		local ui = {
			{text = "New File", x1 = 3, x2 = 12, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "newFile"},
			{text = "Existing File", x1 = 15, x2 = 29, y = 3, col = colours.lime, bracketCol = colours.lightGrey, bgColour = colours.black, option = "existingFile"},
			{text = "Back", x1 = 2, x2 = 7, y = h, col = colours.white, bracketCol = colours.black, bgColour = colours.purple, option = "back"}
		}
		redraw("Edit", ui)
		while true do
			local _, button, xpos, ypos = os.pullEvent("mouse_click")
			for _,pos in pairs(ui) do
				if button == 1 then
					if (xpos >= pos.x1 and xpos <= pos.x2 and ypos == pos.y) then
						if pos.option == "back" then
							redraw("File Manager", main['fileManager'])
							return
						elseif pos.option == "newFile" then
							repeat
								term.clear()
								redraw("New File")
								term.setCursorPos(1,2)
								col(colours.lime)
								print("What file would you like to create?")
								col(colours.white)
								newFile = read()
								term.setCursorPos(1,4)
								if fs.exists(newFile) then
									col(colours.red)
									write("Invalid Arguement: File Exists")
									sleep(1.5)
								end
							until not fs.exists(newFile)
							shell.run("edit",newFile)
						elseif pos.option == "existingFile" then
							repeat 
								path = fileSelect(fileSelectHeader)
								if path == nil then return end
							until path ~= nil
							shell.run("edit",path)
						end
					end
					redraw("Edit", ui)
				end
			end
		end
	end
	local function rename(fileSelectHeader)
		repeat 
			source = fileSelect(fileSelectHeader) 
			if source == nil then return end
		until source ~= nil
		repeat
			redraw("Rename File")
			term.setCursorPos(1,2)
			col(colours.lime)
			print("What would you like to rename this file as?")
			col(colours.white)
			dest = read()
			if dest == "exit()" then
				return nil
			elseif fs.exists(dest) then
				col(colours.red)
				term.setCursorPos(1,4)
				write("Invalid Arguement: File exists")
				sleep(1.5)
			end	
		until not fs.exists(dest)
		shell.run("rename",source,dest)
	end
	local function copy(fileSelectHeader)
		repeat
			source = fileSelect(fileSelectHeader)
			if source == nil then return end
		until source ~= nil
		repeat
			redraw("Copy File")
			col(colours.lime)
			term.setCursorPos(1,2)
			print("Where would you like to copy this file to?")
			col(colours.white)
			dest = read()
			if dest == "exit()" then
				return nil
			elseif fs.exists(dest) then
				col(colours.red)
				term.setCursorPos(1,4)
				write("Invalid Arguement: File exists")
				sleep(1.5)
			end
		until not fs.exists(dest)
		shell.run("copy",source,dest)
	end
	local function move(fileSelectHeader)
		repeat
			source = fileSelect(fileSelectHeader)
			if source == nil then return end
		until source ~= nil
		repeat
			redraw("Move File")
			col(colours.lime)
			term.setCursorPos(1,2)
			print("Where would you like to move this file to?")
			col(colours.white)
			dest = read()
			if dest == "exit()" then return nil
			elseif fs.exists(dest) then
				col(colours.red)
				term.setCursorPos(2,4)
				print("Invalid Arguement: File exists")
				sleep(1.5)
			end
		until not fs.exists(dest)
		shell.run("move",source,dest)
		redraw("File Manager", main['fileManager'])
	end
	local function delete(fileSelectHeader)
		while true do
			local del = fileSelect(fileSelectHeader)
			if del ~= nil then fs.delete(del) else return end
		end
	end
	local fsdelete = fs.delete
	local fsrename = fs.rename
	local fscopy = fs.copy
	local fsmove = fs.move
	function run(fileSelectHeader)
		repeat
			path = fileSelect(fileSelectHeader)
			if path == nil then return end
		until path ~= nil
		local readOnly = fs.list("/.EnderOS")
		local function check(path)
			for i = 1,#readOnly do
				if path == "/.EnderOS/"..readOnly[i] or path == ".EnderOS/"..readOnly[i] then
					return error("Please do not tamper with OS files")
				end
			end
			if path == "/.EnderOS" or path == ".EnderOS" or path == "startup" then
				return error("Please do not tamper with OS files")
			end	
			return path
		end
		function fs.delete(path)
			fsdelete(check(path))
		end
		function fs.rename(source, dest)
			fsrename(check(source), dest)
		end
		function fs.copy(source, dest)
			fscopy(check(source, dest))
		end
		function fs.move(source, dest)
			fsmove(check(source), dest)
		end
		term.clear()
		function runFile() dofile(path) end
		local ok, err = pcall(runFile)
		if not ok then
			redraw("Error!")
			term.setBackgroundColour(colours.purple)
			center("Click anywhere to continue",h)
			term.setBackgroundColour(colours.black)
			term.setCursorPos(1,2)
			printError("Error: "..err)
			while true do
				os.startTimer(0.05)
				local ev = os.pullEvent()
				if ev == "timer" then
					day_time()
				elseif ev == "mouse_click" then
					return
				end
			end
		end
	end
	redraw("File Manager", main["fileManager"])
	while true do
		os.startTimer(0.05)
		local ev, button, xPos, yPos = os.pullEvent()
		if ev == "timer" then
			day_time()
		end
		if ev == "mouse_click" and button == 1 then
				for _,mode in pairs(main["fileManager"]) do
					if (xPos >= mode.x1 and xPos <= mode.x2 and yPos == mode.y) then
						if mode.option == "back" then
							return
						elseif mode.option == "edit" then
							edit(mode.option)
						elseif mode.option == "rename" then
							rename(mode.option)
						elseif mode.option == "copy" then
							copy(mode.option)
						elseif mode.option == "move" then
							move(mode.option)
						elseif mode.option == "delete" then
							delete(mode.option)
						elseif mode.option == "run" then
							run(mode.option)
							fs.rename = fsrename
							fs.delete = fsdelete
						end
					end
				end
			redraw("File Manager", main['fileManager'])
		end
	end
end
local function programs()
	local function redraw(header, bracketText)
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		term.setBackgroundColour(colours.purple)
		col(colours.white)
		center(header,1)
		if bracketText then bracket(bracketText) end
		term.setBackgroundColour(colours.black)
	end
	redraw("Programs", main['programs'])
	while true do
		os.startTimer(0.05)
		local ev, button, xPos, yPos = os.pullEvent()
		if ev == "timer" then
			day_time()
		elseif ev == "mouse_click" and button == 1 then
			for _,tab in pairs(main["programs"]) do
				if (xPos >= tab.x1 and xPos <= tab.x2 and yPos == tab.y) then
					if tab.option == "back" then
						return
					elseif tab.option == "firewolf" then
						run("/.EnderOS/.firewolf")
					elseif tab.option == "calculator" then
						run("/.EnderOS/.calculator")
					end
				end
				redraw("Programs", main['programs'])
			end
		end
	end
end
local function games()
	local function redraw(header, bracketText)
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		term.setBackgroundColour(colours.purple)
		col(colours.white)
		center(header,1)
		if bracketText then bracket(bracketText) end
		term.setBackgroundColour(colours.black)
	end
	redraw("Games", main['games'])
	while true do
		os.startTimer(0.05)
		local ev, button, xPos, yPos = os.pullEvent()
		if ev == "timer" then
			day_time()
		elseif ev == "mouse_click" and button == 1 then
			for _,tab in pairs(main['games']) do
				if (xPos >= tab.x1 and xPos <= tab.x2 and yPos == tab.y) then
					if tab.option == "back" then
						return
					elseif tab.option == "skullPong" then
						run("/.EnderOS/.skullPong")
					elseif tab.option == "guessThatColor" then
						run("/.EnderOS/.guessThatColor")
					end
					redraw("Games", main['games'])
				end
			end
		end
	end
end
local function settings()
	local function redraw(header, bracketText)
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		paintutils.drawLine(1,h,w,h,colours.purple)
		term.setBackgroundColour(colours.purple)
		col(colours.white)
		center(header,1)
		if bracketText then bracket(bracketText) end
		term.setBackgroundColour(colours.black)
	end
	local function change(header, mode, minLimit, path, replaceChar)
		local password = io.open("/.EnderOS/.passInfo","r")
		local passContents = password:read()
		password:close()
		repeat
			redraw(header)
			col(colours.lime)
			print()
			write("Please enter your password\n")
			col(colours.white)
			input = sha256(limitRead(28, "*")..saltHash)
			if input ~= passContents then
				col(colours.red)
				write("\nInvalid password")
				sleep(1)
			end
		until input == passContents
		repeat
			redraw(header)
			print()
			col(colours.lime)
			write("Enter new "..mode.."\n")
			col(colours.white)
			new = limitRead(28, replaceChar or "")
			if #new < (minLimit or 0) then
				col(colours.red)
				write("\nThe Endermen hack you in their sleep!")
				sleep(1)
			end
		until #new >= minLimit
		local handle = io.open(path,"w")
		handle:write(sha256(new..saltHash))
		handle:close()
		col(colours.lightBlue)
		write("\nYour new "..mode.." is "..new)
		sleep(1)
	end
	local function changeHint()
		redraw("Change Hint")
		print()
		col(colours.lime)
		write("Enter new hint\n")
		col(colours.white)
		hint = limitRead(30)
		local handle = io.open("/.EnderOS/.userHint","w")
		handle:write(hint)
		handle:close()
		col(colours.lightBlue)
		write("\nYour new hint is "..hint)
		sleep(1)
	end
	redraw("Settings", main['settings'])
	while true do
		os.startTimer(0.05)
		local ev, button, xPos, yPos = os.pullEvent()
		if ev == "timer" then
			day_time()
		elseif ev == "mouse_click" and button == 1 then
			for _,tab in pairs(main["settings"]) do
				if (xPos >= tab.x1 and xPos <= tab.x2 and yPos == tab.y) then
					if tab.option == "back" then
						return
					elseif tab.option == "changeUsername" then
						change("Change Username", "username", 2, "/.EnderOS/.userInfo")
					elseif tab.option == "changePassword" then
						change("Change Password", "password", 2, "/.EnderOS/.passInfo", "*")
					elseif tab.option == "changeHint" then
						changeHint()
					elseif tab.option == "uninstall" then
						fs.delete("/.EnderOS")
						fs.delete("startup")
						reset()
						os.run({}, "rom/programs/shell")
					end
					redraw("Settings", main['settings'])
				end
			end
		end
	end
end
local function bootOS()
	local function redraw()
		reset()
		paintutils.drawLine(1,1,w,1,colours.purple)
		term.setCursorPos(1,1)
		term.setTextColour(colours.white)
		term.write("EnderOS Console")
		term.setBackgroundColour(colours.black)
		print("")
	end
	if not fs.exists("/.EnderOS/.EnderOSisInstalled") then
		reset()
		col(colours.purple)
		for i = 1,#logo do
			term.setCursorPos(((w-#logo[i])/2)+1,i)
			term.write(logo[i])
		end
		fs.makeDir("/.EnderOS")
		local handle = io.open("/.EnderOS/.EnderOSisInstalled","w")
		handle:close()
		sleep(2.5)
	end
	defineSettings()
	redraw()
	local response = http.get("https://raw.github.com/SuicidalSTDz/EnderOS/master/config")
	local data  = {}
	if not response then
		col(colours.red)
		print("Could not connect to Github!")
		sleep(2)
	else
		local sResponse = response.readLine()
		for sResponse in response.readLine do
			table.insert(data,sResponse)
		end
		response.close()
		if version ~= data[1] then
			col(colours.orange)
			print("An update is available for EnderOS. Would you like to download this update?")
			col(colours.white)
			local input = string.lower(read())
			if input == "yes" then
				col(colours.blue)
				print("Updating EnderOS...")
				if not pastebinGet(data[2] ,"/.EnderOS/.EnderOSUpdate") then
					col(colours.red)
					print("An error has occurred while updating EnderOS")
					sleep(2)
				else
					fs.delete("startup")
					fs.move("/.EnderOS/.EnderOSUpdate","startup")
					col(colours.lime)
					print("EnderOS has updated successfully...")
					sleep(1)
					print("EnderOS is rebooting to apply the updates")
					os.run({},"startup")
				end
			end
		end
		redraw()
	end
	col(colours.orange)
	print("Checking files under directory: /.EnderOS")
	if not fs.exists("/.EnderOS/.desktopIMG") then
		local response = http.get("https://raw.github.com/SuicidalSTDz/EnderOS/master/desktopIMG")
		if not response then
			reset()
			error("Could not download EnderOS desktopScreen")
		else
			local handle = fs.open("/.EnderOS/.desktopIMG","w")
			local sResponse = response.readLine()
			for sResponse in response.readLine do
				handle.writeLine(sResponse)
			end
			response.close()
			handle.close()
		end
	end
	if not fs.exists("/.EnderOS/.loginScreen") then
		local response = http.get("https://raw.github.com/SuicidalSTDz/EnderOS/master/loginScreen")
		if not response then
			reset()
			error("Could not download EnderOS loginScreen")
		else
			local handle = fs.open("/.EnderOS/.loginScreen","w")
			local sResponse = response.readLine()
			for sResponse in response.readLine do
				handle.writeLine(sResponse)
			end
			response.close()
			handle.close()
		end
	end
	for _,v in pairs(boot["files"]) do
		if not fs.exists("/.EnderOS"..v.file) then
			col(colours.red)
			print(" No such file: /.EnderOS"..v.file)
			if not pastebinGet(v.id, "/.EnderOS"..v.file) then
				col(colours.red)
				print("  Could not download file")
			else
				col(colours.lime)
				print("  Downloaded file")
			end
			sleep(0.2)
		else
			col(colours.lime)
			print(" Found file: /.EnderOS"..v.file)
			sleep(0.2)
		end
	end
	sleep(0.2)
end
local function mainOS()
	bootOS()
	login()
	local desktop = paintutils.loadImage("/.EnderOS/.desktopIMG")
	local function redraw()
		paintutils.drawImage(desktop,1,1)
		term.setBackgroundColour(colours.purple)
		term.setTextColour(colours.white)
		center("EnderOS "..version,1)
		bracket(main["desktop"])
	end
	redraw()
	while true do
		os.startTimer(0.05)
		local ev, button, xPos, yPos = os.pullEvent()
		if ev == "timer" then
			day_time()
		elseif ev == "mouse_click" and button == 1 then
			for _,tab in pairs(main["desktop"]) do			
				if (xPos >= tab.x1 and xPos <= tab.x2 and yPos == tab.y) then
					if tab.option == "programs" then
						programs()
					elseif tab.option == "fileManager" then
						fileManager()
					elseif tab.option == "games" then
						games()
					elseif tab.option == "settings" then
						settings()
					elseif tab.option == "logOff" then
						login()
					elseif tab.option == "lock" then
						local handle = io.open("/.EnderOS/.lock","w")
						handle:close()
						login()
					elseif tab.option == "reboot" then
						os.reboot()
					elseif tab.option == "shutdown" then
						os.shutdown()
					elseif tab.option == "exit" then
						reset()
						return
					end
					redraw()
				end
			end
		end
	end
end

--[[Call the OS while capturing any errors returned]]--
if shell.getRunningProgram() ~= "startup" then return error("EnderOS must be contained in a startup file") end
if not http then return error("HTTP must be enabled to use EnderOS") end
if not term.isColor() then return error("Advanced computers are needed to run EnderOS") end
local ok,err = pcall(mainOS)
if not ok then
	reset()
	paintutils.drawLine(1,1,w,1,colours.purple)
	paintutils.drawLine(1,h,w,h,colours.purple)
	col(colours.white)
  	center("The Endermen won't be happy to hear about this!",1)
  	center("Press any key to continue",h)
	term.setBackgroundColour(colours.black)
	col(colours.lime)
	center("- Please PM SuicidalSTDz this error log!",2)
  	center("- Saved as /.EnderOS/.errorLog",3)
	col(colours.red)
	center(err, h/2)
	local errLog = io.open("/.EnderOS/.errorLog","w")
	errLog:write(err)
	errLog:close()
	col(colours.white)
	 while true do
	 	local event = os.pullEvent("mouse_click")
	  	reset()
	 	break
 	end
end
